{
  "rooms": {
    "100A": {
      "id": "100A",
      "title": "Two Sum",
      "difficulty": "Easy",
      "timeLimit": "1000ms",
      "memoryLimit": "256MB",
      "tags": ["Array", "Hash Table", "Two Pointers"],
      "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. The input contains multiple test cases. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
      "inputFormat": "The first line contains an integer t (1 ≤ t ≤ 100), the number of test cases.\nEach test case consists of three lines:\nThe first line contains an integer n (2 ≤ n ≤ 10^4), the number of elements in the array.\nThe second line contains n integers representing the array elements.\nThe third line contains an integer target.",
      "outputFormat": "For each test case, output two integers on a new line representing the indices (0-based) of the two numbers that add up to target.",
      "examples": [
        {
          "input": "2\n4\n2 7 11 15\n9\n5\n3 2 4\n6",
          "output": "0 1\n1 2",
          "explanation": "For the first test case, nums[0] + nums[1] = 2 + 7 = 9. For the second, nums[1] + nums[2] = 2 + 4 = 6."
        }
      ],
      "testInput": "6\n4\n2 7 11 15\n9\n5\n3 2 4\n6\n3\n3 3\n6\n6\n1 2 3 4 5 6\n7\n4\n-1 -2 -3 -4\n-6\n10\n10 20 30 40 50 60 70 80 90 100\n150",
      "expectedOutput": "0 1\n1 2\n0 1\n2 4\n1 3\n4 9",
      "testCasesCount": 6
    },
    "200B": {
      "id": "200B",
      "title": "Valid Parentheses",
      "difficulty": "Easy",
      "timeLimit": "1000ms",
      "memoryLimit": "256MB",
      "tags": ["String", "Stack"],
      "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. You need to solve this problem for multiple test cases.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.",
      "inputFormat": "The first line contains an integer t (1 ≤ t ≤ 100), the number of test cases.\nEach of the next t lines contains a string s (1 ≤ |s| ≤ 10^4).",
      "outputFormat": "For each test case, output \"Valid\" if the string is valid, otherwise output \"Invalid\" on a new line.",
      "examples": [
        {
          "input": "3\n()\n()[]{}\n(]",
          "output": "Valid\nValid\nInvalid",
          "explanation": "First two strings have properly matched brackets, third one doesn't."
        }
      ],
      "testInput": "9\n()\n()[]{}\n(]\n([)]\n{[()]}\n(([]){})\n{{{{\n[()]{}{[()()]()}\n[(])",
      "expectedOutput": "Valid\nValid\nInvalid\nInvalid\nValid\nValid\nInvalid\nValid\nInvalid",
      "testCasesCount": 9
    },
    "300C": {
      "id": "300C",
      "title": "Binary Tree Level Order Traversal",
      "difficulty": "Medium",
      "timeLimit": "2000ms",
      "memoryLimit": "512MB",
      "tags": ["Tree", "BFS", "Binary Tree"],
      "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level). The input contains multiple test cases.\n\nThe tree is represented as a series of node values where -1 represents a null node.",
      "inputFormat": "The first line contains an integer t (1 ≤ t ≤ 50), the number of test cases.\nEach test case consists of two lines:\nThe first line contains an integer n (0 ≤ n ≤ 2000), the number of nodes in the input array.\nThe second line contains n integers representing the tree in level order, where -1 represents null.",
      "outputFormat": "For each test case, output the level order traversal, with each level on a separate line, and nodes on the same level separated by spaces.",
      "examples": [
        {
          "input": "2\n7\n3 9 20 -1 -1 15 7\n1\n1",
          "output": "3\n9 20\n15 7\n1",
          "explanation": "The output for the first test case is followed by the output for the second test case."
        }
      ],
      "testInput": "5\n7\n3 9 20 -1 -1 15 7\n1\n1\n5\n1 2 3 4 5\n9\n1 -1 2 -1 3 -1 4 -1 5\n0\n",
      "expectedOutput": "3\n9 20\n15 7\n1\n1\n2 3\n4 5\n1\n2\n3\n4\n5\n",
      "testCasesCount": 5
    },
    "400D": {
      "id": "400D",
      "title": "Longest Substring Without Repeating Characters",
      "difficulty": "Medium",
      "timeLimit": "2000ms",
      "memoryLimit": "512MB",
      "tags": ["String", "Sliding Window", "Hash Table"],
      "description": "Given a string s, find the length of the longest substring without repeating characters. You must solve this for multiple test cases.",
      "inputFormat": "The first line contains an integer t (1 ≤ t ≤ 100), the number of test cases.\nEach of the next t lines contains a string s (0 ≤ |s| ≤ 5 * 10^4).",
      "outputFormat": "For each test case, output the length of the longest substring without repeating characters on a new line.",
      "examples": [
        {
          "input": "3\nabcabcbb\nbbbbb\npwwkew",
          "output": "3\n1\n3",
          "explanation": "\"abc\" has length 3, \"b\" has length 1, \"wke\" has length 3."
        }
      ],
      "testInput": "9\nabcabcbb\nbbbbb\npwwkew\n\nabcdef\ndvdf\nanviaj\ntmmzuxt\nabacabadabacaba",
      "expectedOutput": "3\n1\n3\n0\n6\n3\n5\n5\n4",
      "testCasesCount": 9
    },
    "500E": {
      "id": "500E",
      "title": "Maximum Subarray Sum",
      "difficulty": "Medium",
      "timeLimit": "2000ms",
      "memoryLimit": "512MB",
      "tags": ["Array", "Dynamic Programming", "Kadane's Algorithm"],
      "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. The input contains multiple test cases.",
      "inputFormat": "The first line contains an integer t (1 ≤ t ≤ 20), the number of test cases.\nEach test case consists of two lines:\nThe first line contains an integer n (1 ≤ n ≤ 10^5), the number of elements.\nThe second line contains n integers representing the array elements.",
      "outputFormat": "For each test case, output the maximum subarray sum on a new line.",
      "examples": [
        {
          "input": "2\n9\n-2 1 -3 4 -1 2 1 -5 4\n1\n5",
          "output": "6\n5",
          "explanation": "For the first case, the subarray [4,-1,2,1] has the largest sum = 6. For the second case, the subarray is [5] itself."
        }
      ],
      "testInput": "5\n9\n-2 1 -3 4 -1 2 1 -5 4\n1\n5\n3\n-3 -2 -1\n5\n1 2 3 4 5\n8\n5 4 -1 7 8 -2 3 1",
      "expectedOutput": "6\n5\n-1\n15\n25",
      "testCasesCount": 5
    },
    "600F": {
      "id": "600F",
      "title": "Merge Intervals",
      "difficulty": "Medium",
      "timeLimit": "2000ms",
      "memoryLimit": "512MB",
      "tags": ["Array", "Sorting", "Intervals"],
      "description": "Given an array of intervals where intervals[i] = [start_i, end_i], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. The input contains multiple test cases.",
      "inputFormat": "The first line contains an integer t (1 ≤ t ≤ 50), the number of test cases.\nFor each test case:\nThe first line contains an integer n (1 ≤ n ≤ 10^4), the number of intervals.\nEach of the next n lines contains two integers representing the start and end of an interval.",
      "outputFormat": "For each test case, output the merged intervals, each interval on a separate line with start and end separated by a space. A blank line should be printed after the output of each test case for clarity.",
      "examples": [
        {
          "input": "2\n4\n1 3\n2 6\n8 10\n15 18\n2\n1 4\n4 5",
          "output": "1 6\n8 10\n15 18\n\n1 5\n",
          "explanation": "For the first case, [1,3] and [2,6] merge to [1,6]. The second case merges [1,4] and [4,5] to [1,5]."
        }
      ],
      "testInput": "4\n4\n1 3\n2 6\n8 10\n15 18\n2\n1 4\n4 5\n5\n1 4\n2 3\n5 7\n6 8\n10 12\n3\n1 10\n2 3\n4 5",
      "expectedOutput": "1 6\n8 10\n15 18\n\n1 5\n\n1 4\n5 8\n10 12\n\n1 10\n",
      "testCasesCount": 4
    },
    "700G": {
      "id": "700G",
      "title": "Coin Change",
      "difficulty": "Medium",
      "timeLimit": "3000ms",
      "memoryLimit": "512MB",
      "tags": ["Dynamic Programming", "BFS", "Array"],
      "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. The input contains multiple test cases.",
      "inputFormat": "The first line contains an integer t (1 ≤ t ≤ 20), the number of test cases.\nEach test case consists of two lines:\nThe first line contains two integers n (1 ≤ n ≤ 12) and amount (0 ≤ amount ≤ 10^4), where n is the number of coin denominations.\nThe second line contains n integers representing the coin denominations.",
      "outputFormat": "For each test case, output the minimum number of coins needed, or -1 if impossible, on a new line.",
      "examples": [
        {
          "input": "2\n3 11\n1 2 5\n1 3\n2",
          "output": "3\n-1",
          "explanation": "For the first case, 11 = 5 + 5 + 1 (3 coins). For the second, amount 3 cannot be made with coin 2."
        }
      ],
      "testInput": "6\n3 11\n1 2 5\n1 3\n2\n3 7\n1 3 4\n1 0\n1\n4 100\n1 10 25 50\n3 6249\n186 419 83",
      "expectedOutput": "3\n-1\n2\n0\n2\n20",
      "testCasesCount": 6
    },
    "800H": {
      "id": "800H",
      "title": "Word Ladder",
      "difficulty": "Hard",
      "timeLimit": "3000ms",
      "memoryLimit": "1024MB",
      "tags": ["Hash Table", "String", "BFS"],
      "description": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that every adjacent pair of words differs by a single letter, every si is in wordList, and sk == endWord. Note that beginWord does not need to be in wordList.\n\nGiven beginWord, endWord, and a wordList, return the number of words in the shortest transformation sequence, or 0 if no such sequence exists. The input contains multiple test cases.",
      "inputFormat": "The first line contains an integer t (1 ≤ t ≤ 10), the number of test cases.\nFor each test case:\nThe first line contains the beginWord and endWord separated by a space.\nThe second line contains an integer n, the number of words in the dictionary.\nThe next n lines contain the dictionary words.",
      "outputFormat": "For each test case, output the length of the shortest transformation sequence, or 0 if no sequence exists, on a new line.",
      "examples": [
        {
          "input": "2\nhit cog\n6\nhot\ndot\ndog\nlot\nlog\ncog\nhit cog\n4\nhot\ndot\ndog\nlot",
          "output": "5\n0",
          "explanation": "For the first case, a valid path is hit -> hot -> dot -> dog -> cog (5 words). For the second, no path exists as 'cog' is not in the list."
        }
      ],
      "testInput": "4\nhit cog\n6\nhot\ndot\ndog\nlot\nlog\ncog\nhit cog\n4\nhot\ndot\ndog\nlot\na c\n3\na\nb\nc\nred tax\n8\nted\ntex\nred\ntax\ntad\nden\nrex\npee",
      "expectedOutput": "5\n0\n2\n4",
      "testCasesCount": 4
    },
    "900I": {
      "id": "900I",
      "title": "Median of Two Sorted Arrays",
      "difficulty": "Hard",
      "timeLimit": "3000ms",
      "memoryLimit": "1024MB",
      "tags": ["Array", "Binary Search", "Divide and Conquer"],
      "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). The input contains multiple test cases.",
      "inputFormat": "The first line contains an integer t (1 ≤ t ≤ 20), the number of test cases.\nEach test case consists of three lines:\nThe first line contains two integers m and n (0 ≤ m, n ≤ 1000, 1 ≤ m + n ≤ 2000).\nThe second line contains m integers representing nums1.\nThe third line contains n integers representing nums2.",
      "outputFormat": "For each test case, output the median as a decimal number with 1 decimal place on a new line.",
      "examples": [
        {
          "input": "2\n2 1\n1 3\n2\n2 2\n1 2\n3 4",
          "output": "2.0\n2.5",
          "explanation": "Case 1: Merged array is [1,2,3], median is 2.0. Case 2: Merged array is [1,2,3,4], median is (2+3)/2 = 2.5."
        }
      ],
      "testInput": "5\n2 1\n1 3\n2\n2 2\n1 2\n3 4\n1 1\n1\n2\n0 5\n\n1 2 3 4 5\n6 2\n1 2 3 4 5 6\n7 8",
      "expectedOutput": "2.0\n2.5\n1.5\n3.0\n4.5",
      "testCasesCount": 5
    },
    "1000J": {
      "id": "1000J",
      "title": "N-Queens",
      "difficulty": "Hard",
      "timeLimit": "5000ms",
      "memoryLimit": "1024MB",
      "tags": ["Array", "Backtracking"],
      "description": "The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle. The input contains multiple test cases.",
      "inputFormat": "The first line contains an integer t (1 ≤ t ≤ 9), the number of test cases.\nEach of the next t lines contains a single integer n (1 ≤ n ≤ 9).",
      "outputFormat": "For each test case, output the number of distinct solutions on a new line.",
      "examples": [
        {
          "input": "2\n4\n1",
          "output": "2\n1",
          "explanation": "There are 2 distinct solutions for n=4 and 1 solution for n=1."
        }
      ],
      "testInput": "9\n1\n2\n3\n4\n5\n6\n7\n8\n9",
      "expectedOutput": "1\n0\n0\n2\n10\n4\n40\n92\n352",
      "testCasesCount": 9
    }
  },
  "metadata": {
    "totalRooms": 10,
    "difficultyDistribution": {
      "Easy": 2,
      "Medium": 5,
      "Hard": 3
    },
    "avgTimeLimit": "2500ms",
    "lastUpdated": "2025-01-19"
  }
}